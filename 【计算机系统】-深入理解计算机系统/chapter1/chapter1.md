- [第 1 章 计算机系统漫游](#第-1-章-计算机系统漫游)
  - [1.1 信息就是位 + 上下文](#11-信息就是位--上下文)
  - [1.2 程序被其他程序翻译成不同的格式](#12-程序被其他程序翻译成不同的格式)
  - [1.3 了解编译系统如何工作是大有益处的](#13-了解编译系统如何工作是大有益处的)
  - [1.4 处理器读并解释储存在内存中的指令](#14-处理器读并解释储存在内存中的指令)
    - [1.4.1 系统的硬件组成](#141-系统的硬件组成)
    - [1.4.2 运行 hello 程序](#142-运行-hello-程序)
  - [1.5 高速缓存至关重要](#15-高速缓存至关重要)
  - [1.6 存储设备形成层次结构](#16-存储设备形成层次结构)
  - [1.7 操作系统管理硬件](#17-操作系统管理硬件)
    - [1.7.1 进程](#171-进程)
    - [1.7.2 线程](#172-线程)
    - [1.7.3 虚拟内存](#173-虚拟内存)
    - [1.7.4 文件](#174-文件)
  - [1.8 系统之间利用网络通信](#18-系统之间利用网络通信)
  - [1.9 重要主题](#19-重要主题)
    - [1.9.1 Amdahl 定理](#191-amdahl-定理)
    - [1.9.2 并发和并行](#192-并发和并行)
    - [1.9.3 计算机系统中抽象的重要性](#193-计算机系统中抽象的重要性)
  - [1.10 小结](#110-小结)

# 第 1 章 计算机系统漫游

**计算机系统**是由硬件和系统软件组成的，它们共同工作来运行应用程序。

```c
#include <stdio.h>

int main() 
{
    printf("hello, world\n");
    return 0;
}
```

我们通过跟踪hello程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。

## 1.1 信息就是位 + 上下文

**源程序/源文件**：（$hello$ 程序/$hello.c$）通过编辑器创建并保存的文本文件。

> 实际上就是一个由值 $0$ 和 $1$ 组成的**位**（**比特**）序列。

**字节**：$8$ 个位被组织在一起。

> 每个字节表示程序中某个文本字符。

大部分的现代计算机系统都使用 $ASCII$ **标准**来表示文本字符：用一个唯一的单字节大小的整数值来每个字符。

> 其他编码方式用于表示非英语类语言文本，具体讨论参照 2.1.4

<div align=center>
  <img src="images\1_1_1.png">
</div>

- 第一个字节整数值是 $35$ ，对应字符”$\#$“
- 第二个字节整数值是 $105$ ，对应字符”$i$“
- ...

每一文本行都是以一个看不见的换行符"$\n$"来结束，对应的整数值是 $10$ 。

像 $hello.c$ 只由 $ASCII$ 字符构成的文件—**文本文件**；所有其他文件—**二进制文件**。

$hello.c$ 表示说明的==基本思想==：系统所有信息（磁盘文件、内存中的程序、内存中存放的用户数据和网络上传输的数据）都是由一串比特表示。区别不同数据对象的唯一方法是读到数据对象时的上下文。

> 在不同的上下文，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。

$C$ 编程语言的起源：

- $C$ 语言是贝尔实验室的 $Dennis Ritchie$ 于 $1969$ 年 ~ $1973$ 年间创建的。
- 美国国家标准学会（American National Standards Institute，ANSI）在 $1989$ 年颁布了 $\text{ANSI C}$ 的标准
- 国际标准化组织（International Standards Organization，ISO）制定 $C$ 语言标准库— $C$ 语言和一系列函数库

$Kernighan$ 和 $Ritchie$ 在他们的经典著作中描述了 $\text{ANSI C}$ —“$\text{K&R}$”。

$Ritchie$ ：” $C$ 语言是“古怪的、有缺陷的，但同时也是一个巨大的成功”。

- $C$ 语言与 $Unix$ 操作系统关系密切；
- $C$ 语言小而简单；
- C 语言是为实践目的设计的。

## 1.2 程序被其他程序翻译成不同的格式

为了在系统上运行 $hello.c$ 程序，

1. 首先将每条 $C$ 语句转化为一系列的低级**机器语言**指令；
2. 并按照一种可**执行目标程序**的格式打好包为**可执行目标文件**；
3. 然后以二进制磁盘文件的形式存放起来。

在 $Unix$ 系统上，从源文件到目标文件的转化是由**编译器驱动程序**完成的：

`linux>gcc -o hello hello.c`

*意义*：$GCC$ 编译器驱动程序读取源文件 $hello.c$，并翻译为可执行文件 $hello$。

分为四个阶段，而执行这四个阶段的程序构成了**编译系统（compilation system）**。

<div align=center>
  <img src="images\1_2_1.png">
</div>

- **预处理阶段**：**预处理器**（$cpp$）根据字符 $\text{#}$ 开头的命令，修改原始的 $.c$ 文件。

  - `#include <stdio.h>`：读取 $stdio.h$ 的内容，直接插入程序文本中
  - $\color{red}{hello.c \longrightarrow hello.i}$

- **编译阶段**：**编译器**（$ccl$）将高级语言翻译成汇编语言。

  - 包含一个汇编语言程序：

    ```
    1 	main:
    2 		subq		$8，%工sp
    3 		movl		$.LCo,%edi
    4 		call		puts
    5 		movl		$0，%eax
    6 		addq 		$8，%rsp
    7		ret
    ```

  - $\color{red}{hello.i \longrightarrow hello.s}$

> 汇编语言为不同高级语言的不同编译器提供了通用的输出语言。

- **汇编阶段**：**汇编器**（$as$）将汇编语言翻译成机器语言指令。
  - $hello.s$ 翻译成机器语言指令打包成**可重定位目标程序**的格式并保存到 $hello.o$
  - $\color{red}{hello.s \longrightarrow hello.o}$
- **链接阶段**：**链接器**（$ld$）合并不同的 $.o$ 文件，加载到内存中，由系统执行。
  - $hello$ 程序调用了 $printf$ 函数（$printf$ 函数存在 $printf.o$ 中，将 $printf.o$ 以某种方式合并到二进制文件 $hello.o$ 中），得到 $hello$
  - $\color{red}{hello.o \longrightarrow hello}$

| 文件名    | 格式       | 类型             | 文件         |
| --------- | ---------- | ---------------- | ------------ |
| $hello.c$ | 文本文件   | $C$ 程序         | 源文件       |
| $hello.i$ | 文本文件   | 汇编程序         | 汇编文件     |
| $hello.o$ | 二进制文件 | 可重定向目标程序 | 可重定向文件 |
| $hello$   | 二进制文件 | 可执行目标程序   | 可执行文件   |

$GUN$ **项目**：

- $GNU$ 项目是 $1984$ 年由 $Richard Stallman$ 发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发出一个完整的类 $Unix$ 的系统，其源代码能够不受限制地被修改和传播。$GNU$ 项目已经开发出了一个包含 $Unix$ 操作系统的所有主要部件的环境，但内核除外，内核是由 $Linux$ 项目独立发展而来的。

- $GNU$ 环境包括：
  - $EMACS$ 编辑器
  - $GCC$ 编译器
  - $GDB$ 调试器
  - 汇编器
  - 链接器
  - 处理二进制文件的工具
  - 其他一些部件。

- $GCC$ 编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。
  
- 支持的语言包括$C$、$C++$、$Fortran$、$Java$、$Pascal$、面向对象 $C$ 语言（$Objective-C$）和 $Ada$ 。
  
- $GNU$ 项目取得了非凡的成绩，但是却常常被忽略。

  > 现代开放源码运动（通常和 $Linux$ 联系在一起)的思想起源是 $GNU$ 项目中**自由软件**的概念。而且，$Linux$ 如此受欢迎在很大程度上还要归功于 $GNU$ 工具，它们给 $Linux$ 内核提供了环境。

## 1.3 了解编译系统如何工作是大有益处的

*为什么我们需要知道编译系统是如何工作的*？

- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞

## 1.4 处理器读并解释储存在内存中的指令

$hello.c \longrightarrow hello$

要想在 $Unix$ 上运行可执行文件，可以将文件名输入到 $shell$ 应用程序中

$shell$ ：命令解释器，输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，shell 会假设这是一个可执行文件的名字加载并运行这个文件。

### 1.4.1 系统的硬件组成

来了解一个典型系统的硬件知识。

举例：$Intel$ 系统产品族的模型（所有其他系统也有相同的外观和特性）

<div align=center>
  <img src="images\1_4_1.png" height="50%" width="50%">
</div>

**总线**：

- 贯穿这个系统的一组电子管道；
- 携带信息字节并负责在各个部件间传递；
- 通常总线被设计成传送定长的字节块—**字**。

> 字的字节数（**字长**）：一个基本的系统参数，各个系统不相同，大多数机器字长 $4$ 个字节（$32$位）和 $8$ 个字节（$64$位）

**$I/O$ 设备**：系统与外部世界的联系通道。

示例的系统包括有 $4$ 个 $I/O$ 系统：

1. 作为用户输入的键盘和鼠标
2. 作为用户输出的显示器
3. 用于长期存储数据和程序的**硬盘驱动器（磁盘）**

- 每个 $I/O$ 设备都通过一个控制器或适配器与 $I/O$ 总线相连（二者区别在于封装方式）
  - **控制器**：$I/O$ 设备本身或者系统的**主印刷电路版（主板）**。
  - **适配器**：插在主板插槽上的卡。

**主存**：临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。

*物理上*：一组动态随机存取存储器（$DRAM$）芯片

*逻辑上*：一个线性的字节数组，每个字节都有唯一的地址（数组索引）

**处理器/中央处理单元**：解释（执行）在主存中指令的引擎。

- 处理器的核心是一个大小为一个字的存储设备（或**寄存器**）—**程序计数器（$PC$）** ：任何适合，$PC$ 都指向主存中某条机器语言指令（即含有该条指令的地址）；
- 处理器按照一个非常简单的指令执行模型（由指令集架构决定）来操作的；
- 从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令；
- 执行一条指令包含执行一系列的步骤：
  - 处理器从 $PC$ 指向的内存处读取指令，
  - 解释指令中的位，
  - 执行该指令指示的简单操作
  - 更新 $PC$ ，使其指向下一条指令，

> 下一条指令并不一定和在内存中刚刚执行的指令相邻

$\color{red}{处理器围绕主存、寄存器文件和算术/逻辑单元进行。}$：

**寄存器文件**：一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。

**算术/逻辑单元**：计算新的数据和地址值。

处理器在指令要求下可能会执行的操作：

- 加载：从主存复制一个字节或者一个字到寄存器。
- 存储：从寄存器复制一个字节或一个字到主存。
- 操作：把两个寄存器的内容复制到算术/逻辑单元然后对两个内容做算术运算，将结果存放到一个寄存器中。
- 跳转：从指令中抽取一个字，将字复制到程序计数器中。

==处理器的指令集架构 && 处理器的微体系结构==

指令集架构：描述每条机器代码指令的效果。

微体系结构：描述处理器实际上的实现。

### 1.4.2 运行 hello 程序

$\color{green}{shell 执行指令等待我们输入命令...}$

$\color{green}{输入字符串 ./hello ，shell 将字符逐一读入寄存器，并存放入内存中}$

<div align=center>
  <img src="images\1_4_2.png" height="50%" width="50%">
</div>

$\color{green}{输入回车键， shell 执行一系列指令来加载可执行文件 hello ，将 hello 目标文件中的代码和数据从磁盘复制到主存}$

<div align=center>
  <img src="images\1_4_3.png" height="50%" width="50%">
</div>

一旦可执行文件中的代码和数据被加载到主存

$\color{green}{处理器开始执行 hello 程序的 main 程序中的机器语言指令}$

将"$hello,world\n$"：

1. 从主存复制到寄存器文件
2. 从寄存器文件复制到显示设备
3. 由显示设备显示在屏幕上

<div align=center>
  <img src="images\1_4_4.png" height="50%" width="50%">
</div>

## 1.5 高速缓存至关重要



## 1.6 存储设备形成层次结构

## 1.7 操作系统管理硬件

### 1.7.1 进程

### 1.7.2 线程

### 1.7.3 虚拟内存

### 1.7.4 文件

## 1.8 系统之间利用网络通信

## 1.9 重要主题

### 1.9.1 Amdahl 定理

### 1.9.2 并发和并行

### 1.9.3 计算机系统中抽象的重要性

## 1.10 小结

